<!-- Author: Ian Smith (imsmith@uw.edu) -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="Pragma" content="no-cache">
<title>Plot View</title>

<!-- chart dependencies -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js" type="text/javascript"></script>
<script src="/highcharts.src.js" type="text/javascript"></script>

<!-- ASCOT Basic Style Sheets -->
<link href="/css/reset.css" rel="stylesheet" type="text/css">
<link href="/css/text.css" rel="stylesheet" type="text/css"> 

<style type="text/css">
td{
  padding: 5px;
}
</style>

<script type="text/javascript">

// Constants
var DEFAULT_MARKER_COLOR = 'rgba(100, 100, 100, .7)';
var MARKER_COLOR = {
  red: 'rgba(255, 0, 0, .7)',
  green: 'rgba(0, 255, 0, .7)',
  blue: 'rgba(0, 0, 255, .7)',
  yellow: 'rgba(220, 220, 0, .7)',
  unselect: 'rgba(100, 100, 100, .7)' 
};  

// Highcharts plot
var plot;

// Gadget sate
var axisInverted = {x: false, y: false};
var verboseTooltip = false;
var selectedDataSetName = "";
var selectedXAxis = "";
var selectedYAxis = "";
var selectedColor = "";
var selectedDataSet = "";
var selectionObject;

//Load gadget state

// Gadget intialization
gadget.init = function(callback){
  gadget.onNotification('dataSetChanged', redrawAll);  
  gadget.onNotification('plotRendered', syncPlot);
  gadget.onNotification('pointsSelected', setSelectedByMinMax);
  gadget.onNotification('axisInverted', invertAxis);
  callback();
  
  $("#checkVerboseInfo").change( function(){
    verboseTooltip = $("#checkVerboseInfo").get(0).checked;
  });
  
  // add colors to the select box (pass the select Name and color array)
  $('#selectDatasetName').change( function(){
    if(this.selectedIndex != -1){
      selectedDataSetName = this[this.selectedIndex].value;
      selectedDataSet = gadget.dashboard.getDataSet(selectedDataSetName);
      if(selectedDataSet){
        columnNames = selectedDataSet.getColumns();
        populateSelect("selectXAxis", columnNames, selectedXAxis);
        populateSelect("selectYAxis", columnNames, selectedYAxis);
      }
    }    
  });
  
  $('#selectXAxis').change( function(){
    if(this.selectedIndex != -1){
      selectedXAxis = this[this.selectedIndex].value;
    }
  });
  
  $('#selectYAxis').change( function(){
    if(this.selectedIndex != -1){
      selectedYAxis = this[this.selectedIndex].value;
    }
  });
  
  $('#selectColor').change( function(){
    if(this.selectedIndex != -1){
      selectedColor = this[this.selectedIndex].value;
    }
  });  
    
  $('#invertXAxisButton').click(invertX);
  $('#invertYAxisButton').click(invertY);
  $('#plotButton').click(plotData);
  plot = new Highcharts.Chart(chartOptions);     
  populateSelect("selectColor", ["red", "green", "blue", "yellow", "unselect"],selectedColor);
  if(axisInverted.x){
    axisInverted.x = false;
    invertX();
  }
  if(axisInverted.y){
    axisInverted.y = false;
    invertY();
  }
}

gadget.saveState = function(){
  return { 
    'axisInverted': axisInverted,
    'verboseTooltip': verboseTooltip,
    'selectedDataSetName': selectedDataSetName,
    'selectedXAxis': selectedXAxis,
    'selectedYAxis': selectedYAxis,
    'selectedColor': selectedColor,
    'selectedDataSet': selectedDataSet,
    'selectionObject': selectionObject
  }
};

gadget.loadState = function(state){
   if(isDef(state.axisInverted)){
	  axisInverted = state.axisInverted;
	}
	if(isDef(state.verboseTooltip)){
	  verboseTooltip = state.verboseTooltip;
	  $("#checkVerboseInfo").get(0).checked = verboseTooltip;
	}
	if(isDef(state.selectedDataSetName)){
	  selectedDataSetName = state.selectedDataSetName;
   }
   if(isDef(state.selectedXAxis)){
	  selectedXAxis = state.selectedXAxis;
	}
	if(isDef(state.selectedYAxis)){  
	  selectedYAxis = state.selectedYAxis;
   }
   if(isDef(state.selectedColor)){
	  selectedColor = state.selectedColor;
   }
   if(isDef(state.selectedDataSet)){
	  selectedDataSet = state.selectedDataSet;
   }
   if(isDef(state.selectionObject)){
	  selectionObject = state.selectionObject;
   }
};

// Check definedness
function isDef(testvar){
  if (typeof testvar === 'undefined') {
    return false;
  }
  else {
    return true;
  }
}

// Highcharts plot options
var chartOptions = {
  chart: {
    renderTo: 'divPlot',
    defaultSeriesType: 'scatter',
    zoomType: 'xy',
    events : {
      selection: function(selectionEvent) {
      // check if the zoom or select radio is checked
      // also, only select if there is an xAxis property in event (allows reset zoom)
        if ($('#radioSelect').get(0).checked && ("xAxis" in selectionEvent)) {
          selectionEvent.preventDefault();
          selectionObject = {'seriesId': 'series1', 'xMin': selectionEvent.xAxis[0].min, 'xMax':  selectionEvent.xAxis[0].max, 
                              'yMin': selectionEvent.yAxis[0].min, 'yMax':  selectionEvent.yAxis[0].max, color: selectedColor};
          // We make this call ashyncronous and the plot gives the impression of being more responsive
          setTimeout("gadget.dashboard.notify('pointsSelected', selectionObject)",1);                                 
        }
      }
    }
  },
  credits: { enabled: false },
  legend: { enabled: false},
  title: { text: '' },
  loading: { showDuration: 0, hideDuration: 0 },
  xAxis: {
    title: { enabled: false, text: '' },
    reversed: false,
    startOnTick: true,
    endOnTick: true,
    showLastLabel: true
  },
  yAxis: {
    title: { text: '' },
    reversed: false
  },
  tooltip: {
    formatter: function() { return generateToolTip(this.x, this.y, this.point.id) }
  },
  plotOptions: {
    scatter: {
      animation: false,
      color: DEFAULT_MARKER_COLOR, 
      id: 'series1'                    
    }
  },
  series: [{
    name: '',
    data: [],
    point: {
      events: {
        click: function(event) {
          if (!(event.ctrlKey || event.metaKey)) { // check windows ctrl and mac meta
            // color point
            var selectedMarkerColor = selectedColor;
            if (getPointColor(this) !== selectedMarkerColor) {
              setPointColor(this, selectedMarkerColor);
            } 
            else {
              setPointColor(this, "");
            }
            plot.redraw();
          } 
          else { // zoom to point
            zoomToPoint(this); 
          }
        }
      }
    }
  }]
} 

function generateToolTip(xValue, yValue, pointId) {  
  var dataSet;
  var record;
  var info = [];
  if (verboseTooltip) {
    record = selectedDataSet.getRecord(pointId);
    if (record){
      for (var prop in record) {
        info.push(prop + ": " + record[prop] + "<br/>");
      }
    }
    return info.join("");
  } 
  else { 
    return  $(plot.yAxis[0].axisTitle.element).text() + ' : ' + yValue + '<br/>' + $(plot.xAxis[0].axisTitle.element).text()  +' : ' + xValue;
  }
}


function plotData(){
  if (selectedDataSetName ===  "" || selectedXAxis === "" || selectedYAxis === "") {
    alert("Choose a dataset, x axis, and y axis");
    return;
  }
  else{
    drawPlot();
    gadget.notify("plotRendered", { 'dataSetName': selectedDataSetName, 'color': selectedColor, 'xAxis': selectedXAxis, 'yAxis': selectedYAxis }, {'private': true});
  }
}
                                                                        
function redrawAll(){
  var columnNames = [];
  populateSelect('selectDatasetName', gadget.dashboard.getDataSetList(), selectedDataSetName);
  if(selectedDataSet){
    columnNames = selectedDataSet.getColumns();
    populateSelect("selectXAxis", columnNames, selectedXAxis);
    populateSelect("selectYAxis", columnNames, selectedYAxis);
  }
  drawPlot();
}
  
function setSelectedByMinMax(obj) {
  var data = plot.get(obj.seriesId).data;
  var selectedIds = [];  
  var selectedMarkerColor = obj.color; 
  var point;
  var color;
  var i;

  for (i=0, len=data.length; i<len; i++){ 
    point = data[i];
    if (point.x <= obj.xMax && point.x >= obj.xMin && point.y <= obj.yMax && point.y >= obj.yMin) {
      // point.id looks like: p0 
      // so we strip the first letter to get the db_id
      selectedIds.push(point.id);             
      colorChartPoint(point, selectedMarkerColor);
    }
  }
  // update the dataset with the selected points 
  // set dataset points colors in bulk
  if(selectedIds.length > 0){
    color = (selectedMarkerColor === "unselect") ? "grey" : selectedMarkerColor;
    selectedDataSet.setRecords({'color': color}, selectedIds); 
  }
   
}

// Checks the public dataset to update the selection status of all the points in the chart
function updateSelectedPoints() {
  var colorIndexArray;
  var colorIndex;
  var point;

  if(plot == null)
    return;	
    
  plot.showLoading();
  // select or unselect all the points in the chart to change the way they look
  if (!selectedDataSet) {
    return;
  }
  colorIndexArray = selectedDataSet.getAttributeValues('color');
  // color selected points
  for (color in colorIndexArray){
    colorIndex = colorIndexArray[color];
    for (var j=0, lenj=colorIndex.length; j<lenj; j++){
      point = plot.get(colorIndex[j]);  // id is [0]
      if (point !== null) {
        colorChartPoint(point, color);  
      }
    }
  }
  plot.hideLoading();
}

// Colors a selected point on chart by the color name
function colorChartPoint(point, colorName) {
  if (colorName === "") {
    colorName = "unselect";
  }
  point.update({color: MARKER_COLOR[colorName], marker: {fillColor: MARKER_COLOR[colorName]}}, false);
}

// colors chart point and writes it to dataset
function setPointColor(point, colorName) {
  if (colorName === "unselect") {
    colorName = "";
  }
  colorChartPoint(point, colorName);
  selectedDataSet.setRecords({'color': colorName}, point.id);  
}

// Zooms the viewport to point by writing CelestialCoordinate to public variable
function zoomToPoint(point) {
  var cc = selectedDataSet.getRecord(point.id);
  if (cc !== null && cc !== undefined) {
    gadget.notify("centerOfCoordinatesChanged",{'longitude': parseFloat(cc.ra) - 180, 'latitude': parseFloat(cc.dec)});
  }
}

function getPointColor(point) {
  return selectedDataSet.getRecord(point.id);
}

function drawPlot() {
  if (selectedDataSetName ===  "" || selectedXAxis === "" || selectedYAxis === "") {
    return;
  }
  plot.setTitle({ text: selectedDataSetName });
  
  // Set Data + Axis labels + Redraw
  if(plot.xAxis[0].axisTitle && plot.xAxis[0].axisTitle){
     $(plot.xAxis[0].axisTitle.element).text(selectedXAxis);
     $(plot.yAxis[0].axisTitle.element).text(selectedYAxis);
  }
  else{
    plot.series[0].xAxis.options.title.text = selectedXAxis;
    plot.series[0].yAxis.options.title.text = selectedYAxis;
  }
  // Legend
  //$(plot.series[0].legendItem.element).text(yAxisLabel + " vs " + xAxisLabel)
  plot.series[0].setData(generatePoints(), true);

  $('#divPlot').css('height', '400px');
  updateSelectedPoints(); 
  showPlot(true); 
}

function generatePoints(){
  var xValue;
  var yValue;
  var shift;
  var points = [];
  if (!selectedDataSet)
    return points;
  
  for (i=0,len=selectedDataSet.length(); i<len; i++) {
    xValue = selectedDataSet.getRecord(i)[selectedXAxis]; 
    xValue = /\./.test(xValue)? parseFloat(xValue) : xValue;
    yValue = selectedDataSet.getRecord(i)[selectedYAxis];
    yValue = /\./.test(yValue)? parseFloat(yValue) : yValue;
    // each point has unique id so a pointer to point can be had by chart.get(id)
    if (xValue !== NaN && yValue !== NaN){
      points.push({'id': selectedDataSet.getRecord(i)["id"],
                    x: xValue, 
                    y: yValue,
                    color: MARKER_COLOR[selectedDataSet.getRecord(i).color],
                    marker: { fillColor: MARKER_COLOR[selectedDataSet.getRecord(i).color] } 
                  });
    }
  }
  return points;
}    

function showPlot(show) {
  if (show) {
    $('#divPlot').css('display', 'block');
  }
  else {
    $('#divPlot').css('display', 'hidden');
  }
	gadget.resize();
}

function populateSelect(selectName, options, selectedOption) { 
  var html = '';
  var currentSelection = $("#" + selectName + " option:selected").text();
  var len = options.length;
  var keepSelection = false;
  for (var i = 0; i< len; i++) {
    if (options[i]===currentSelection && !selectedOption){
      keepSelection = true;
    }
    html += '<option value="' + options[i] + '">' + options[i] + '</option>';
  }
  $("#" + selectName).html(html);
  if(keepSelection){
    $("#" + selectName).val(currentSelection).attr('selected',true);    
  }else if(isDef(selectedOption)){
    $("#" + selectName).val(selectedOption).attr('selected',true);
  }else{
    $("#" + selectName).val(options[0]).attr('selected',true);
  }
  
  $('#' + selectName).change();
}
    
function syncPlot(plotOptions){
  
  $('#selectDatasetName option[value=' + plotOptions.dataSetName + ']').attr('selected', 'selected');
  $('#selectXAxis option[value=' + plotOptions.xAxis + ']').attr('selected', 'selected');
  $('#selectYAxis option[value=' + plotOptions.yAxis + ']').attr('selected', 'selected');
  $('#selectColor option[value=' + plotOptions.color + ']').attr('selected', 'selected');
  $('#selectDatasetName').change();
  $('#selectXAxis').change();
  $('#selectYAxis').change();
  $('#selectColor').change();
  
  drawPlot();
  
}    
    
function invertAxis(axis){
  if(axis === "x")
    axisInverted.x = !axisInverted.x;
  else
    axisInverted.y = !axisInverted.y;
  
  if (plot) {
    plot.xAxis[0].reversed = axisInverted.x;
    plot.yAxis[0].reversed = axisInverted.y;
  }
  drawPlot();
}          

function invertX(){
  var value = $('#invertXAxisButton').get(0).value; 
  if (value === '>') {
    $('#invertXAxisButton').get(0).value = '<';
  } else {
    $('#invertXAxisButton').get(0).value = '>';
  }
  gadget.notify('axisInverted',"x")
}

function invertY(){
  var value = $('#invertYAxisButton').get(0).value; 
   if (value === '^') {
     $('#invertYAxisButton').get(0).value = ('v');
   } else {
     $('#invertYAxisButton').get(0).value = ('^');
   }
  gadget.notify('axisInverted',"y")
}
      
</script>
</head>
<body>
<div id="content">
  <div id="divSelectDataset" style="display: inline">  
    <table style="margin: 0px"><tbody>
      <tr>
        <td> Dataset: <select id="selectDatasetName"></select>
        </td>
        <td>    
          X Axis: <input id="invertXAxisButton" type="button" title="Invert X Axis" value=">"></input> <select id="selectXAxis"></select>
        </td>
        <td>
          Y Axis: <input id="invertYAxisButton" type="button" title="Invert Y Axis" value="^"></input> <select id="selectYAxis"></select>
        </td>
      </tr>
      <tr>
        <td>
          <input id="plotButton" type="button" value="Plot"/>
        </td> 
      </tr> 
    </tbody></table>
  </div>
  <div id="divPlotToolbar" style="display: inline">
    <form name="formSelectZoom">
      <div id="divSelectZoom" style="padding: 5px">
        Selection Color: <select id="selectColor"></select>
        <input type="radio" id="radioSelect" name="radSelectZoom" value="select" checked="checked" /><label for="radSelect">Select</label>
        <input type="radio" id="radioZoom" name="radSelectZoom" value="zoom" /><label for="radZoom">Zoom</label>
        Info: <input type="checkbox" id="checkVerboseInfo" value="0"/>
      </div>
    </form>
  </div>
  <div id="divPlot" style="display: none"></div>
</div>
</body>
</html>