<?xml version="1.0" encoding="UTF-8"?>
<!-- scalableScatter.xml -->
<!-- Author: Spencer Wallace (spencerw@email.arizona.edu) -->
<html lang="en">
<meta http-equiv="Pragma" content="no-cache">

<head>
<title>Scalable Scatter Plot</title>

<!-- chart dependencies -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js" type="text/javascript"></script>
<script src="../js/highcharts/highcharts.js" type="text/javascript"></script>
<script type="text/javascript" src="scalableScatter.js"></script>

<!-- ASCOT Basic Style Sheets -->
<link href="/css/960/reset.css" rel="stylesheet" type="text/css">
<link href="/css/960/text.css" rel="stylesheet" type="text/css"> 

<script type="text/javascript">

// Prevent the background image from being dragged when the user
// drags a selection box across the plot
window.ondragstart = function() { return false; } 

// The plot gadget
var pl = null;

// GLOBAL CONSTANTS
var chart1;                  // The highcharts chart object
var dataToPlot;              // The data that is going to be plotted
var maxDensity;              // The maximum number of points allowed in a bin before a rectangle is drawn
var numBinsX;                // The number of bins along the x-axis. Y-axis bins are scaled accordingly
var imgPath = 'images/grid.gif'; // The path to the background image
var imgPosX = 100;           // The x and y coordinates of the upper right corner of the background image (in the same units as the axes, not pixels)
var imgPosY = 0.75;
var imgWidth = 300;          // The height and width of the background image (in the same units as the axes, not pixels)
var imgHeight = 0.5;

// Create the Plotter object
function init() {
	pl = new Plotter();
	gadget.resize();
}

function Plotter() {	
	var my = new Object();
	
	// PRIVATE
	var primitiveObjects = [] // References to the primitive objects drawn on the chart
	var originalSizeX;		  // Size variables for the background image
	var originalMinX;
	var originalSizeY;
	var originalMinY;
	var pointsInBounds; 	     // An array of all of the datapoints that fall into the current bounds of the plot
	var lowDensityPoints = [] // An array of all of the datapoints that fall in low enough density regions
	var numBinsY;             // The number of y bins is automatically adjusted according to numBinsX so that the bins are square
	var dataExtremes;         // Find the extremes of the dataset to be plotted to set the initial window bounds
	var bins;                 // Holds information about the density of each part of the plot
	var sparsePoints;         // Points far enough apart to be drawn individually
	
	var currentDatasetName = ""; // The name of the dataset to be loaded
	myFields = { }				     // Pointers to HTML fields on the page
	axisInverted = { x: false,   // Tells whether the x and y axis should be inverted
                    y: false };
	
	gadget.dashboard.bind('dataSetListChanged', updateDataSetList);
	
	// When the list of public datasets change, rewrite the list of available datasets to plot    
	function updateDataSetList(){
    	setSelectOptions("selDatasetName", gadget.dashboard.getDataSetList());
	}
	
	// GETS for the HTML controls on the page       
   function getSelectedDataset() {
   	return getSelectedOption("selDatasetName");
   }
   function getSelectedXAxis() {
      return getSelectedOption("selXAxis");
   }
   function getSelectedYAxis() {
      return getSelectedOption("selYAxis");
   }
   
   function parseData(args) {
   	// TODO: verify the necessary args were passed
   	var xCol = args.xAxis;
   	var yCol = args.yAxis;
        
   	var ds = gadget.dashboard.getDataSet(args.dataSetName);
                
  	 	var graphData = [];
  		var dsData = ds.toJSON();
   	for (i=0,len=dsData.length; i<len; i++) {
   		var xVal = parseFloat(dsData[i][xCol]);
   		var yVal = parseFloat(dsData[i][yCol]);
   		// each point has unique id so a pointer to point can be had by chart.get(id)
      	var id = "p" + dsData[i]["db_id"];
      	if (xVal !== NaN && yVal !== NaN){
      		graphData.push([xVal,yVal]);
     		}
     	}
     	
     	return graphData;
	}
	
	function displayPlot(args) {
		chart1 = new Highcharts.Chart({
			chart: {
				renderTo: 'divChart1',
				defaultSeriesType: 'scatter',
				zoomType: 'xy',
				events: {
					load: function() { handleLoadEvent(this); },
					redraw: function() { handleRedrawEvent(this); },
					click: function(event) { handleClickEvent(this,event); }
				}
			},
			title: {
				text: 'Generic Density Plot'
			},
			xAxis: {
				title: {
					enabled: true,
					text: args.xAxis
				},
				reversed: axisInverted.x,
				startOnTick: false,
				endOnTick: false,
				// Make the scales 0.1% longer to keep bin boundaries within the confines of the window
				min: dataExtremes.domain.min-(dataExtremes.domain.max-dataExtremes.domain.min)*0.001,
				max: dataExtremes.domain.max+(dataExtremes.domain.max-dataExtremes.domain.min)*0.001,
				maxPadding: 0
			},
			yAxis: {
				title: {
					text: args.yAxis
				},
				reversed: axisInverted.y,
				startOnTick: false,
				endOnTick: false,
				// Make the scales 0.1% longer to keep bin boundaries within the confines of the window
				min: dataExtremes.range.min-(dataExtremes.range.max-dataExtremes.range.min)*0.001,
				max: dataExtremes.range.max+(dataExtremes.range.max-dataExtremes.range.min)*0.001,
				maxPadding: 0
			},
			series: [{
				name: 'Entire Dataset',
				color: 'rgba(223, 83, 83, .5)',
				// Plot a dummy point so that the axes initalize correctly
				data: [[0,0]],
				showInLegend: false
			}]
		});
		
		// Hide the dummy point at (0,0)
		chart1.series[0].hide();
	}
	
	// PRIVATE METHODS
	function handleLoadEvent(chart) {
		// Set the number of y bins so that the bins stay square
		numBinsY = Math.ceil(numBinsX * (chart.plotHeight/chart.plotWidth));
		// Record the scale and minimums of the axes so the background can be resized accordingly later on
      originalMinX = chart.xAxis[0].getExtremes().min;
      originalSizeX = chart.xAxis[0].getExtremes().max - originalMinX;
      originalMinY = chart.yAxis[0].getExtremes().min;
      originalSizeY = chart.yAxis[0].getExtremes().max - originalMinY;
	}
	
	function handleRedrawEvent(chart) {
		gadget.resize();
		// Remove all of the exisiting primitive objects
      for (var i = 0; i < primitiveObjects.length; i++) {
         primitiveObjects[i].destroy();
      }
      
      // Draw a white rectangle over the background to clear out the previous background image
		primitiveObjects.push(chart.renderer.rect(0,0,chart.chartWidth, chart.chartHeight, 0)
       							 .attr({fill: 'white', zIndex: 0}).add());
      // Draw the background image
      var currentMinX = chart.xAxis[0].getExtremes().min;
      var currentSizeX = chart.xAxis[0].getExtremes().max - currentMinX;
      var currentMinY = chart.yAxis[0].getExtremes().min;
      var currentSizeY = chart.yAxis[0].getExtremes().max - currentMinY;
      primitiveObjects.push(chart.renderer.image(imgPath, 
          						(imgPosX-currentMinX)*(chart.plotWidth/currentSizeX)+chart.plotLeft, 				       // X position
          						chart.plotHeight-((imgPosY-currentMinY)*(chart.plotHeight/currentSizeY)-chart.plotTop), // Y position
          						imgWidth*(chart.plotWidth/originalSizeX)*(originalSizeX/currentSizeX), 			          // Width
          						imgHeight*(chart.plotHeight/originalSizeY)*(originalSizeY/currentSizeY))			       // Height
          						.attr({ zIndex: 0}).add());
      // Draw white rectangles over the edges of the chart to prevent the background image from
      // appearing outside of the plot window
      primitiveObjects.push(chart.renderer.rect(0,chart.plotHeight+chart.plotTop,					// Bottom
							       chart.chartWidth, chart.chartHeight-chart.plotHeight, 0)
       							 .attr({fill: 'white',zIndex: 0}).add());
      primitiveObjects.push(chart.renderer.rect(0,0,											            // Top
							       chart.chartWidth, chart.plotTop, -1)
							       .attr({fill: 'white',zIndex: 0}).add());
      primitiveObjects.push(chart.renderer.rect(0,0,															// Left
							       chart.plotLeft, chart.chartHeight, 0)
       							 .attr({fill: 'white',zIndex: 0}).add());
      primitiveObjects.push(chart.renderer.rect(chart.plotLeft+chart.plotWidth,0,					// Right
							       chart.plotLeft, chart.chartHeight, 0)
       							 .attr({fill: 'white',zIndex: 0}).add());
   	
   	// Figure out which data points fall within the current window of the plot
      pointsInBounds = []
      for (var i = 0; i < dataToPlot.length; i++) {
      	if (dataToPlot[i][0] >= chart.xAxis[0].getExtremes().min && 
         	dataToPlot[i][0] <= chart.xAxis[0].getExtremes().max &&
            dataToPlot[i][1] >= chart.yAxis[0].getExtremes().min &&
            dataToPlot[i][1] <= chart.yAxis[0].getExtremes().max) {
            pointsInBounds.push(dataToPlot[i]);
        	}
     	}
     	
     	// Determine the density of each part of the plot
		bins = getBins(chart,numBinsX,numBinsY,pointsInBounds);
		// Figure out which points to draw individually
		sparsePoints = getIndividualPts(chart,pointsInBounds,bins,maxDensity);
		// Draw the rectangles and points
      primitiveObjects = drawData(chart,bins,sparsePoints,maxDensity,axisInverted);
	}
	
	function handleClickEvent(chart,event) {
		// Figure out which bin was clicked on
		var xBinClicked = Math.floor((event.xAxis[0].value-chart.xAxis[0].getExtremes().min)/
								(chart.xAxis[0].getExtremes().max-chart.xAxis[0].getExtremes().min)*numBinsX);
		var yBinClicked = Math.floor((event.yAxis[0].value-chart.yAxis[0].getExtremes().min)/
								(chart.yAxis[0].getExtremes().max-chart.yAxis[0].getExtremes().min)*numBinsY);

		// If the bin we clicked on has more than maxDensity points in it
		if (bins[xBinClicked][yBinClicked].length > maxDensity) {
			alert('Bin ['+xBinClicked+','+yBinClicked+'] selected');
			// List all of the points in the bin
			// Only list the first ten for now
			for (var i = 0; i < bins[xBinClicked][yBinClicked].length; i++) {
				if (i > 10) {
					break;
				}
									
				//alert("[" + bins[xBinClicked][yBinClicked][i][0] + "," + bins[xBinClicked][yBinClicked][i][1] + "]");
			}
		}
		// Otherwise, we must be clicking on an individual point
		else {
			// If the mouse click falls within the bounds of one of the individual points
			// Get that data point from the sparsePoints array
			for (var i = 0; i < sparsePoints.length; i++) {
				// Find the distance in pixels between the mouse click and the drawn point
				// Need to translate mouse click and data point coordinates into pixel coordinates
				var mousePixelX = Math.ceil((event.xAxis[0].value-chart.xAxis[0].getExtremes().min)/
													(chart.xAxis[0].getExtremes().max-chart.xAxis[0].getExtremes().min)*chart.plotSizeX);
				var mousePixelY = Math.ceil((event.yAxis[0].value-chart.yAxis[0].getExtremes().min)/
													(chart.yAxis[0].getExtremes().max-chart.yAxis[0].getExtremes().min)*chart.plotSizeY);
																
				var coordPixelX = Math.ceil((sparsePoints[i][0]-chart.xAxis[0].getExtremes().min)/
													(chart.xAxis[0].getExtremes().max-chart.xAxis[0].getExtremes().min)*chart.plotSizeX);
				var coordPixelY = Math.ceil((sparsePoints[i][1]-chart.yAxis[0].getExtremes().min)/
													(chart.yAxis[0].getExtremes().max-chart.yAxis[0].getExtremes().min)*chart.plotSizeY);
																
				var clickDist = Math.sqrt((mousePixelX-coordPixelX)*(mousePixelX-coordPixelX) + 
													(mousePixelY-coordPixelY)*(mousePixelY-coordPixelY))
																
				if (clickDist < 5) {
					alert("[" + sparsePoints[i][0] + ", " + sparsePoints[i][1] + "]");
				}
			} 
		}
	}
	
	// accepts name of select box
   // returns the value in the select box, or ""
   function getSelectedOption(select) {
	   var selName = getField(select);
      if (selName.length > 0){
 	     return selName.options[selName.selectedIndex].value;
      } else {
	      return "";
      }
	}
	
	// Accepts the name of a select object, and an array of strings
   // replaces the options with the array of strings
	function setSelectOptions(selectName, options) {
   	var select = getField(selectName);
      if (select === null) {
  	   	return;
      }
      // save old selected option so maybe it can be reselected
      var selectedOption = getSelectedOption(selectName);
      // Default. First option selected
      if (selectedOption == "")
     		 selectedOption == options[0];
      // clear options
      select.length = 0;
      // add options
      for (var i=0, len=options.length; i<len; i++) {
      	// if oldOption is in the list, then select it
         select.add(new Option(options[i], options[i], false, (selectedOption == options[i])), null);
      }
      if(select.onchange)
      	select.onchange();
	}
	
	function getField(field) {
   	if (!(field in myFields) || (myFields[field] === null)) {
     		myFields[field] = document.getElementById(field);
      }
   	return myFields[field];
	}
	
	// PUBLIC METHODS
	my.invertX = function() {
   	var anchor = document.getElementById('butXInvert');
      if (anchor.value === ">") {
      	anchor.value = "<";
      } else {
      	anchor.value = ">";
      }
        axisInverted.x = !axisInverted.x;
        if (chart1 !== null && chart1 !== undefined) {
            this.doPlot();
        }
    }
    
    my.invertY = function() {
   	var anchor = document.getElementById('butYInvert');
      if (anchor.value === "^") {
      	anchor.value = "v";
      } else {
      	anchor.value = "^";
      }
        axisInverted.y = !axisInverted.y;
        if (chart1 !== null && chart1 !== undefined) {
            this.doPlot();
        }
    }
	
	// Populates the X/Y axis dropdowns with values from the chosen datasets column names
   // If no dataset is chosen, then it blanks them
   my.populateXYSelect = function(datasetName) {
  		// TODO get dataset names
		var columnNames = [""];
      if (datasetName !== "") {
      	var ds = gadget.dashboard.getDataSet(datasetName);
         columnNames = ds.getNonDBColumns();
  		}
   	setSelectOptions("selXAxis", columnNames);
   	setSelectOptions("selYAxis", columnNames);
   }
	
	my.doPlot = function() {
		// Read the values in from the forms
		maxDensity = document.getElementById('maxDensityInput').value;
		numBinsX = document.getElementById('numBinsXInput').value;
		imgPosX = document.getElementById('imgPosXInput').value;
		imgPosY = document.getElementById('imgPosYInput').value;
		imgWidth = document.getElementById('imgWidthInput').value;
		imgHeight = document.getElementById('imgHeightInput').value;
		
		// Init the dataset
		currentDatasetName = getSelectedDataset();
      var datasetName = currentDatasetName;
      var xAxisName = getSelectedXAxis();
      var yAxisName = getSelectedYAxis();
      
      //TODO: confirm dataset actually exists with this name
      if (datasetName ===  "" || xAxisName === "" || yAxisName === "") {
      	alert("Choose a dataset, x axis, and y axis");
      	return;
      }
      
      var dataInput = { 'dataSetName': datasetName,
                        'xAxis': getSelectedXAxis(),
                        'yAxis': getSelectedYAxis()
                      };
		
		// Read the data in and figure out the max and min of the dataset
		dataToPlot = parseData(dataInput);
		dataExtremes = getDataExtremes(dataToPlot);
		
		displayPlot(dataInput);
	}

	return my;	
}

</script>
</head>
<body onload="init();">
<div id="content">
	<!-- The scatter plot -->
	<div id="divChart1" style="width: 600px; height: 400px; margin: 0 auto"></div>

	<!-- The plot controls -->
	Dataset: <select id="selDatasetName" onchange="pl.populateXYSelect(this.options[this.selectedIndex].value);"></select>
	X-Axis: <input id="butXInvert" type="button" title="Invert X Axis" value=">" onclick="pl.invertX();"></input><select id="selXAxis"></select>
	Y-Axis: <input id="butYInvert" type="button" title="Invert Y Axis" value="^" onclick="pl.invertY();"></input><select id="selYAxis"></select><br>
	<input id="btDoPlot" onclick="pl.doPlot();" type="button" value="Plot"/><br>
	
	maxDensity: <input type="text" id="maxDensityInput" value="2" /><br>
	numBinsX: <input type="text" id="numBinsXInput" value="35" /><br>
	imgPosX: <input type="text" id="imgPosXInput" value="100" /><br>
	imgPosY: <input type="text" id="imgPosYInput" value="0.75" /><br>
	imgWidth: <input type="text" id="imgWidthInput" value="300" /><br>
	imgHeight: <input type="text" id="imgHeightInput" value="0.5" />
</div>

</body>
</html>
