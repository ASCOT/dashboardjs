<?xml version="1.0" encoding="UTF-8"?>
<!-- scalableScatter.xml -->
<!-- Author: Spencer Wallace (spencerw@email.arizona.edu) -->
<html lang="en">
<meta http-equiv="Pragma" content="no-cache">

<head>
<title>Scalable Scatter Plot</title>

<!-- chart dependencies -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js" type="text/javascript"></script>
<script src="../js/highcharts/highcharts.js" type="text/javascript"></script>

<!-- ASCOT Basic Style Sheets -->
<link href="/css/960/reset.css" rel="stylesheet" type="text/css">
<link href="/css/960/text.css" rel="stylesheet" type="text/css"> 

<script type="text/javascript">

// Prevent the background image from being dragged when the user
// drags a selection box across the plot
window.ondragstart = function() { return false; } 

// The plot gadget
var pl = null;

// GLOBAL CONSTANTS
var chart1;                  // The highcharts chart object
var dataToPlot;              // The data that is going to be plotted
var maxDensity;              // The maximum number of points allowed in a bin before a rectangle is drawn
var numBinsX;                // The number of bins along the x-axis. Y-axis bins are scaled accordingly
var imgPath; 					  // The path to the background image
var imgPosX = 100;           // The x and y coordinates of the upper right corner of the background image (in the same units as the axes, not pixels)
var imgPosY = 0.75;
var imgWidth = 300;          // The height and width of the background image (in the same units as the axes, not pixels)
var imgHeight = 0.5;

// Create the Plotter object
function init() {
	pl = new Plotter();
	pl.setSelectOptions("selSelectionColor", ["red", "green", "blue", "yellow", "unselect"]);
	gadget.resize();
}

function Plotter() {	
	var my = new Object();
	
	// PRIVATE
	var primitiveObjects = [] // References to the primitive objects drawn on the chart
	var originalSizeX;		  // Size variables for the background image
	var originalMinX;
	var originalSizeY;
	var originalMinY;
	var pointsInBounds; 	     // An array of all of the datapoints that fall into the current bounds of the plot
	var lowDensityPoints = [] // An array of all of the datapoints that fall in low enough density regions
	var numBinsY;             // The number of y bins is automatically adjusted according to numBinsX so that the bins are square
	var dataExtremes;         // Find the extremes of the dataset to be plotted to set the initial window bounds
	var bins;                 // Holds information about the density of each part of the plot
	var sparsePoints;         // Points far enough apart to be drawn individually
	var tooltip;				  // Reference to the current tooltip object on the screen
	var selectedPts = []		  // Points that have been selected by the user
	
	var currentDatasetName = ""; // The name of the dataset to be loaded
	myFields = { }				     // Pointers to HTML fields on the page
	
	// The invert buttons have been left out for now
	// There are a few issues with the invert function that need to be fixed such as
	// the background image needing to be flipped and problems with the selection box
	// when the axes are flipped
	axisInverted = { x: false,   // Tells whether the x and y axis should be inverted
                    y: false };
                    
   // CHART CONSTANTS
   var DEFAULT_MARKER_COLOR = 'rgba(0, 0, 0, 0)';
       SELECTED_MARKER_COLOR = 'rgba(210,30,100,.9)'
       MARKER_COLOR = { red: 'rgba(255, 0, 0, .7)',
                        green: 'rgba(0, 255, 0, .7)',
                        blue: 'rgba(0, 0, 255, .7)',
                        yellow: 'rgba(220, 220, 0, .7)',
                        unselect: DEFAULT_MARKER_COLOR
                       }
	
	gadget.dashboard.bind('dataSetListChanged', updateDataSetList);
	
	// When the list of public datasets change, rewrite the list of available datasets to plot    
	function updateDataSetList(){
    	setSelectOptions("selDatasetName", gadget.dashboard.getDataSetList());
    	updateSelectedPoints();
	}
	
	// Given a list of point ids, change those points in the public dataset to a given color
	function setSelectedColor(obj) {
		var ds = gadget.dashboard.getDataSet(getSelectedDataset());
		var useColor = obj.color;
		if (obj.color == 'unselect') {
			useColor = '';
		}
		ds.setIndexesColor(obj.modifiedPointIds,useColor);
      gadget.dashboard.trigger('dataSetListChanged');
		return;
	}
	
	// Checks the public dataset to update the selection status of all the points in the chart
   // TODO: set the color according to the ds color
   function updateSelectedPoints() {
    
   	if(chart1 == null)
    		return;	
    	// select or unselect all the points in the chart to change the way they look
    	var ds = gadget.dashboard.getDataSet(getSelectedDataset());
    	if (ds === undefined || ds === null) {
   	 	return;
   	 }
    	var colorIndexArray = ds.getColoredIndexArray();
        
    	// color selected points
   	for (var i=0, len=colorIndexArray.length; i<len; i++){
   		var point;
    		for (var j=0; j < dataToPlot.length; j++) {
    			if (("p" + colorIndexArray[i][0]) == dataToPlot[i].id)
    				point = dataToPlot[i];
    		}
     		if (point !== null) {
      		colorChartPoint(point, colorIndexArray[i][1] );  // color is [1]
      	}
    	}
    	chart1.redraw();
    	//gadget.dashboard.setDataSet(getSelectedDataset(), ds);
	}
	
	 // Colors a selected point on chart by the color name
    function colorChartPoint(point, colorName) {
        if (colorName === "") {
            colorName = "unselect";
        }
        point.color = MARKER_COLOR[colorName];
    }
	
	// GETS for the HTML controls on the page       
   function getSelectedDataset() {
   	return getSelectedOption("selDatasetName");
   }
   function getSelectedXAxis() {
      return getSelectedOption("selXAxis");
   }
   function getSelectedYAxis() {
      return getSelectedOption("selYAxis");
   }
   
   function parseData(args) {
   	// TODO: verify the necessary args were passed
   	var xCol = args.xAxis;
   	var yCol = args.yAxis;
        
   	var ds = gadget.dashboard.getDataSet(args.dataSetName);
   	var colorIndexArray = ds.getColoredIndexArray();
                
  	 	var graphData = [];
  		var dsData = ds.toJSON();
   	for (i=0,len=dsData.length; i<len; i++) {
   		var xVal = parseFloat(dsData[i][xCol]);
   		var yVal = parseFloat(dsData[i][yCol]);
   		// each point has unique id so a pointer to point can be had by chart.get(id)
      	var id = "p" + dsData[i]["db_id"];
      	if (xVal !== NaN && yVal !== NaN){
      		graphData.push({id: id, x: xVal, y: yVal, color: colorIndexArray[i][1] });
     		}
     	}
     	
     	return graphData;
	}
	
	// Find the domain and range max and min of a dataset
	function getDataExtremes(data) {
		var extremes = { range: {
			min: Number.MAX_VALUE,
			max: Number.MIN_VALUE
		},
		domain: {
			min: Number.MAX_VALUE,
			max: Number.MIN_VALUE
		}
		};

		// Loop through the data and find the min and max values
		for (var i = 0; i < data.length; i++) {

			// Domain
			if (data[i].x < extremes.domain.min) {
				extremes.domain.min = data[i].x;
			}
			if (data[i].x > extremes.domain.max) {
				extremes.domain.max = data[i].x;
			}	

			// Range
			if (data[i].y < extremes.range.min) {
				extremes.range.min = data[i].y;
			}
			if (data[i].y > extremes.range.max) {
				extremes.range.max = data[i].y;
			}
		}

		return extremes;
	}
	
	// Break a plot up into a certain number of bins given a dataset
	function getBins(data) {

		// Get the extremes for each axis to determine the vertices of each bin
		var domainExtremes = chart1.xAxis[0].getExtremes();
		var rangeExtremes = chart1.yAxis[0].getExtremes();

		// Set the width and height of each box
		var binHeight = (domainExtremes.max-domainExtremes.min)/numBinsX;
		var binWidth = (rangeExtremes.max-rangeExtremes.min)/numBinsY;

		// Initalize the 2D array of bins, set inital values to 0	
		var _bins = new Array(numBinsX);
		for (var i = 0; i < numBinsX; i++) {
			_bins[i] = new Array(numBinsY);
		}
		for (var row = 0; row < numBinsX; row++) {
			for (var col = 0; col < numBinsY; col++) {
				_bins[row][col] = new Array();
			}
		}

		// Loop through the data points and place each one in the correct bin
		for (var i = 0; i < data.length; i++) {
			// Determine the correct x and y bin to place this data element into
			var xBin = Math.floor(((data[i].x - domainExtremes.min)/
					(domainExtremes.max-domainExtremes.min))*numBinsX);
			var yBin = Math.floor(((data[i].y - rangeExtremes.min)/
					(rangeExtremes.max-rangeExtremes.min))*numBinsY);
	
			// Push this data point onto the array of bins in the correct place
			_bins[xBin][yBin].push(data[i]);

		}

		return _bins;
	}
	
	// Determine which points in the current plot window are of low enough density
	// to be plotted individually
	function getIndividualPts(data) {

		// The individual points that are sparse enough to be plotted
		var pointsToPlot = []

		// Get the extremes for each axis
		var domainExtremes = chart1.xAxis[0].getExtremes();
		var rangeExtremes = chart1.yAxis[0].getExtremes();

		for (var i = 0; i < data.length; i++) {	
			// Figure out which bin this point belongs in
			var xBin = Math.floor(((data[i].x - domainExtremes.min)/
					(domainExtremes.max-domainExtremes.min))*bins.length);
			var yBin = Math.floor(((data[i].y - rangeExtremes.min)/
					(rangeExtremes.max-rangeExtremes.min))*bins[0].length);
	
			// Add this point to the plot list if the bin is not over the density limit
			if (bins[xBin][yBin].length < maxDensity) {
				pointsToPlot.push(data[i]);
			}
		}

		return pointsToPlot;
	}
	
	// Draw the rectangles and points on the chart
	function drawData(sparsePts) {

		// An array that stores references to all of the primitive objects created
		var primitiveObjects = []

		// Figure out how many pixels large each bin is
		var binPixelWidth = chart1.plotWidth/bins.length;
		var binPixelHeight = chart1.plotHeight/bins[0].length;
		
		// Find the range of densities in the graph
		var largestDensity = Number.MIN_VALUE;
		for (var i = 0; i < bins.length; i++) {
			for (var j = 0; j < bins[0].length; j++) {
				if (bins[i][j].length > largestDensity) {
					largestDensity = bins[i][j].length;
				}
			}
		}
		var densityRange = largestDensity - maxDensity;

		// Draw the rectangles over areas with high density
		for (var i = 0; i < bins.length; i++) {
			for (var j = 0; j < bins[0].length; j++) {
				if (bins[i][j].length > maxDensity) {
		
					// Scale the opacity of the fill color based on the density
					var fillColor = 'rgba(255,0,0,'+ ((bins[i][j].length - maxDensity)/densityRange) +')';
					
					var xPos = i*binPixelWidth+chart1.plotLeft;
					var yPos = chart1.plotHeight+chart1.plotTop-binPixelHeight-j*binPixelHeight;
					
					if (axisInverted.x) {
						xPos = (chart1.plotWidth+chart1.plotLeft-binPixelWidth)-i*binPixelWidth;
					}
					if (axisInverted.y) {
						yPos = chart1.plotTop+j*binPixelHeight;
					}
					
					var strokeWidth = 0;
					var strokeColor = '#0000FF';
					// Bins with selected points have a blue border
					for (var k = 0; k < bins[i][j].length; k++) {
						if (bins[i][j][k].color != DEFAULT_MARKER_COLOR) {
							strokeWidth = 1;
							strokeColor = bins[i][j][k].color;
							break;
						}
					}
											
					primitiveObjects.push(chart1.renderer.rect(xPos,yPos,binPixelWidth,binPixelHeight,0)
										.attr({stroke: strokeColor,'stroke-width': strokeWidth,fill: fillColor,zIndex: 100}).add());
				}
			}
		}

		// Draw the individual points in areas with low density
		for (var i = 0; i < sparsePts.length; i++) {
	
			var xPos = chart1.xAxis[0].translate(sparsePts[i].x)+chart1.plotLeft;
			var yPos = chart1.plotHeight-chart1.yAxis[0].translate(sparsePts[i].y)+chart1.plotTop;
			
			primitiveObjects.push(chart1.renderer.circle(xPos,yPos,4).attr({fill: sparsePts[i].color,stroke: 'black','stroke-width': 1,zIndex: 100}).add());	
		}

		return primitiveObjects;
	}
	
	// Draw a tooltip box on the chart
	function drawTooltip(text,position) {
		var primitiveObjects = {}
	
		// Draw the text
		primitiveObjects.text = chart1.renderer.text(text,position.x,position.y).attr({ zIndex: 5 }).add();
		var bBox = primitiveObjects.text.getBBox();
	
		// Draw the box around it
		primitiveObjects.box = chart1.renderer.rect(bBox.x - 5, bBox.y - 5, bBox.width + 10, bBox.height + 10, 5)
         	       .attr({fill: '#FFFFEF',stroke: 'gray','stroke-width': 1,zIndex: 4}).add();
				 
		return primitiveObjects;
	}
	
	function displayPlot(args) {
		chart1 = new Highcharts.Chart({
			chart: {
				renderTo: 'divChart1',
				defaultSeriesType: 'scatter',
				zoomType: 'xy',
				events: {
					load: function() { handleLoadEvent(this); },
					redraw: function() { handleRedrawEvent(this); },
					click: function(event) { handleClickEvent(this,event); },
					selection: function(event) { handleSelectEvent(this,event); }
				}
			},
			legend: {
         	layout: 'horizontal',
      	 	floating: false,
     	   	backgroundColor: '#FFFFFF',
    	    	align: 'left',
     	   	verticalAlign: 'top',
     	   	y: 60,
     	   	x: -60
         },
			title: {
				text: 'Generic Density Plot'
			},
			credits: {
                    enabled: false
         },
			xAxis: {
				title: {
					enabled: true,
					text: args.xAxis
				},
				reversed: axisInverted.x,
				startOnTick: false,
				endOnTick: false,
				// Make the scales 0.1% longer to keep bin boundaries within the confines of the window
				min: dataExtremes.domain.min-(dataExtremes.domain.max-dataExtremes.domain.min)*0.001,
				max: dataExtremes.domain.max+(dataExtremes.domain.max-dataExtremes.domain.min)*0.001,
				maxPadding: 0
			},
			yAxis: {
				title: {
					text: args.yAxis
				},
				reversed: axisInverted.y,
				startOnTick: false,
				endOnTick: false,
				// Make the scales 0.1% longer to keep bin boundaries within the confines of the window
				min: dataExtremes.range.min-(dataExtremes.range.max-dataExtremes.range.min)*0.001,
				max: dataExtremes.range.max+(dataExtremes.range.max-dataExtremes.range.min)*0.001,
				maxPadding: 0
			},
			series: [{
				name: 'Entire Dataset',
				color: 'rgba(223, 83, 83, .5)',
				// Plot a dummy point so that the axes initalize correctly
				data: [[0,0]],
				showInLegend: false
			}]
		});
		
		// Hide the dummy point at (0,0)
		chart1.series[0].hide();
	}
	
	// PRIVATE METHODS
	function handleLoadEvent(chart) {
		// Set the number of y bins so that the bins stay square
		numBinsY = Math.ceil(numBinsX * (chart.plotHeight/chart.plotWidth));
		// Record the scale and minimums of the axes so the background can be resized accordingly later on
      originalMinX = chart.xAxis[0].getExtremes().min;
      originalSizeX = chart.xAxis[0].getExtremes().max - originalMinX;
      originalMinY = chart.yAxis[0].getExtremes().min;
      originalSizeY = chart.yAxis[0].getExtremes().max - originalMinY;
      updateSelectedPoints();
	}
	
	// TODO: Figure out a way to flip the image when the axes are inverted
	function handleRedrawEvent(chart) {
		gadget.resize();
		// Remove all of the exisiting primitive objects
      for (var i = 0; i < primitiveObjects.length; i++) {
         primitiveObjects[i].destroy();
      }
      
      // Draw a white rectangle over the background to clear out the previous background image
		primitiveObjects.push(chart.renderer.rect(0,0,chart.chartWidth, chart.chartHeight, 0)
       							 .attr({fill: 'white', zIndex: 0}).add());
      // Draw the background image
      var currentMinX = chart.xAxis[0].getExtremes().min;
      var currentSizeX = chart.xAxis[0].getExtremes().max - currentMinX;
      var currentMinY = chart.yAxis[0].getExtremes().min;
      var currentSizeY = chart.yAxis[0].getExtremes().max - currentMinY;
      
      var xPos = chart.xAxis[0].translate(imgPosX)+chart.plotLeft;
      var yPos = chart.yAxis[0].translate(imgPosY)+chart.plotTop;
      var width = imgWidth*(chart.plotWidth/originalSizeX)*(originalSizeX/currentSizeX);
      var height = imgHeight*(chart.plotHeight/originalSizeY)*(originalSizeY/currentSizeY);
      
      primitiveObjects.push(chart.renderer.image(imgPath,
      							(imgPosX-currentMinX)*(chart.plotWidth/currentSizeX)+chart.plotLeft,                // X position
      							chart.plotHeight-((imgPosY-currentMinY)*(chart.plotHeight/currentSizeY)-chart.plotTop), // Y position
      							imgWidth*(chart.plotWidth/originalSizeX)*(originalSizeX/currentSizeX),						// Width
      							imgHeight*(chart.plotHeight/originalSizeY)*(originalSizeY/currentSizeY))             // Height
      							.attr({ zIndex: 0}).add());
      // Draw white rectangles over the edges of the chart to prevent the background image from
      // appearing outside of the plot window
      primitiveObjects.push(chart.renderer.rect(0,chart.plotHeight+chart.plotTop,					// Bottom
							       chart.chartWidth, chart.chartHeight-chart.plotHeight, 0)
       							 .attr({fill: 'white',zIndex: 0}).add());
      primitiveObjects.push(chart.renderer.rect(0,0,											            // Top
							       chart.chartWidth, chart.plotTop, -1)
							       .attr({fill: 'white',zIndex: 0}).add());
      primitiveObjects.push(chart.renderer.rect(0,0,															// Left
							       chart.plotLeft, chart.chartHeight, 0)
       							 .attr({fill: 'white',zIndex: 0}).add());
      primitiveObjects.push(chart.renderer.rect(chart.plotLeft+chart.plotWidth,0,					// Right
							       chart.plotLeft, chart.chartHeight, 0)
       							 .attr({fill: 'white',zIndex: 0}).add());
   	
   	// Figure out which data points fall within the current window of the plot
      pointsInBounds = []
      for (var i = 0; i < dataToPlot.length; i++) {
      	if (dataToPlot[i].x >= chart.xAxis[0].getExtremes().min && 
         	dataToPlot[i].x <= chart.xAxis[0].getExtremes().max &&
            dataToPlot[i].y >= chart.yAxis[0].getExtremes().min &&
            dataToPlot[i].y <= chart.yAxis[0].getExtremes().max) {
            pointsInBounds.push(dataToPlot[i]);
        	}
     	}
     	
     	// Determine the density of each part of the plot
		bins = getBins(pointsInBounds);
		// Figure out which points to draw individually
		sparsePoints = getIndividualPts(pointsInBounds);
		// Draw the rectangles and points
      primitiveObjects = drawData(sparsePoints);
	}
	
	function handleClickEvent(chart,event) {
		// If the radio button is set to zoom, click does nothing
		if (isRadioZoom())
			return;
	
		// Figure out which bin was clicked on
		var xBinClicked = Math.floor((event.xAxis[0].value-chart.xAxis[0].getExtremes().min)/
								(chart.xAxis[0].getExtremes().max-chart.xAxis[0].getExtremes().min)*numBinsX);
		var yBinClicked = Math.floor((event.yAxis[0].value-chart.yAxis[0].getExtremes().min)/
								(chart.yAxis[0].getExtremes().max-chart.yAxis[0].getExtremes().min)*numBinsY);

		// If the bin we clicked on has more than maxDensity points in it
		if (bins[xBinClicked][yBinClicked].length > maxDensity) {
			// Determine the bounding box of this bin
			var binBox = { x: { min: chart.xAxis[0].getExtremes().min+((chart.xAxis[0].getExtremes().max-chart.xAxis[0].getExtremes().min)/numBinsX)*xBinClicked,
									  max: chart.xAxis[0].getExtremes().min+((chart.xAxis[0].getExtremes().max-chart.xAxis[0].getExtremes().min)/numBinsX)*(xBinClicked+1)},
								y: { min: chart.yAxis[0].getExtremes().min+((chart.yAxis[0].getExtremes().max-chart.yAxis[0].getExtremes().min)/numBinsY)*yBinClicked,
									  max: chart.yAxis[0].getExtremes().min+((chart.yAxis[0].getExtremes().max-chart.yAxis[0].getExtremes().min)/numBinsY)*(yBinClicked+1)}
							 };
			
			// Select all of the points in the bin
			var modifiedPointIds = []
			for (var i = 0; i < dataToPlot.length; i++) {
				if (dataToPlot[i].x < binBox.x.max && dataToPlot[i].x > binBox.x.min) {
					if (dataToPlot[i].y < binBox.y.max && dataToPlot[i].y > binBox.y.min) {
						// Need to strip the first letter from dataToPlot.id to use to query database
						var databaseId = dataToPlot[i].id;
						modifiedPointIds.push(databaseId.substr(1));
					}
				}
			}
			var selectionObj = {modifiedPointIds: modifiedPointIds, color: getSelectionMarkerColor()};
			setSelectedColor(selectionObj);
		}
		// Otherwise, we must be clicking on an individual point
		else {
			// If the mouse click falls within the bounds of one of the individual points
			// Get that data point from the sparsePoints array
			
			// Need to translate mouse click and data point coordinates into pixel coordinates
			var mousePixelX = chart.xAxis[0].translate(event.xAxis[0].value);
			var mousePixelY = chart.yAxis[0].translate(event.yAxis[0].value);
												
			for (var i = 0; i < sparsePoints.length; i++) {
				// Find the distance in pixels between the mouse click and the drawn point					
				var coordPixelX = chart.xAxis[0].translate(sparsePoints[i].x);
				var coordPixelY = chart.yAxis[0].translate(sparsePoints[i].y);
																
				var clickDist = Math.sqrt((mousePixelX-coordPixelX)*(mousePixelX-coordPixelX) + 
													(mousePixelY-coordPixelY)*(mousePixelY-coordPixelY))
																
				if (clickDist < 5) {
					setSelectedColor({modifiedPointIds: [sparsePoints[i].id.substr(1)], color: getSelectionMarkerColor()});
				}
			} 
		}
		chart.redraw();
	}
	
	function handleSelectEvent(chart,event) {
		if (!isRadioZoom() && ("xAxis" in event)) {
			event.preventDefault();
			// Check which data points are inside the selection box
			var modifiedPointIds = []
			for (var i = 0; i < dataToPlot.length; i++) {
				if (dataToPlot[i].x < event.xAxis[0].max && dataToPlot[i].x > event.xAxis[0].min) {
					if (dataToPlot[i].y < event.yAxis[0].max && dataToPlot[i].y > event.yAxis[0].min) {
						// Need to strip the first letter from dataToPlot.id to use to query database
						var databaseId = dataToPlot[i].id;
						modifiedPointIds.push(databaseId.substr(1));
					}
				}
			}
			var selectionObj = {modifiedPointIds: modifiedPointIds, color: getSelectionMarkerColor()};
			setSelectedColor(selectionObj);
		}
	}
	
	// returns the color name in the selection color dropdown
   function getSelectionMarkerColor() {
   	return colorText = getSelectedOption("selSelectionColor");
   }
   // returns the value in the selection color dropdown as an 'rgba(r,g,b,a)' string for chart
   function getSelectionMarkerRgba() {
   	return MARKER_COLOR[getSelectionMarkerColor()];
   }
	
	// accepts name of select box
   // returns the value in the select box, or ""
   function getSelectedOption(select) {
	   var selName = getField(select);
      if (selName.length > 0){
 	     return selName.options[selName.selectedIndex].value;
      } else {
	      return "";
      }
	}
	
	// Accepts the name of a select object, and an array of strings
   // replaces the options with the array of strings
	function setSelectOptions(selectName, options) {
   	var select = getField(selectName);
      if (select === null) {
  	   	return;
      }
      // save old selected option so maybe it can be reselected
      var selectedOption = getSelectedOption(selectName);
      // Default. First option selected
      if (selectedOption == "")
     		 selectedOption == options[0];
      // clear options
      select.length = 0;
      // add options
      for (var i=0, len=options.length; i<len; i++) {
      	// if oldOption is in the list, then select it
         select.add(new Option(options[i], options[i], false, (selectedOption == options[i])), null);
      }
      if(select.onchange)
      	select.onchange();
	}
	
	function getField(field) {
   	if (!(field in myFields) || (myFields[field] === null)) {
     		myFields[field] = document.getElementById(field);
      }
   	return myFields[field];
	}
	
	function getRadioValue(radio) {
   	if (!radio) {
   		return "";
   	}
   	for (var i=0, len=radio.length; i<len; i++) {
   		if (radio[i].checked) {
   			return radio[i].value;
   		}
   	}
   	return "";
   }
	
	function isRadioZoom() {
   	return (getRadioValue(document.formSelectZoom.radSelectZoom) === "zoom");
   }
   
   // returns the color name in the selection color dropdown
   function getSelectionMarkerColor() {
   	return colorText = getSelectedOption("selSelectionColor");
   }
	
	// PUBLIC METHODS
	my.invertX = function() {
   	var anchor = document.getElementById('butXInvert');
      if (anchor.value === ">") {
      	anchor.value = "<";
      } else {
      	anchor.value = ">";
      }
        axisInverted.x = !axisInverted.x;
        if (chart1 !== null && chart1 !== undefined) {
            chart1.redraw();
        }
    }
    
    my.invertY = function() {
   	var anchor = document.getElementById('butYInvert');
      if (anchor.value === "^") {
      	anchor.value = "v";
      } else {
      	anchor.value = "^";
      }
        axisInverted.y = !axisInverted.y;
        if (chart1 !== null && chart1 !== undefined) {
            chart1.redraw();
        }
    }
	
	// Populates the X/Y axis dropdowns with values from the chosen datasets column names
   // If no dataset is chosen, then it blanks them
   my.populateXYSelect = function(datasetName) {
  		// TODO get dataset names
		var columnNames = [""];
      if (datasetName !== "") {
      	var ds = gadget.dashboard.getDataSet(datasetName);
         columnNames = ds.getNonDBColumns();
  		}
   	setSelectOptions("selXAxis", columnNames);
   	setSelectOptions("selYAxis", columnNames);
   }
   
   my.exportSelected = function() {
   
   	// Get the dataset name
   	var dsName = document.getElementById('exportSelectedInput').value;
   	if (dsName.length < 1) {
      	showError("Enter export name");
      	return;
      }
      
      // Create a new dataset of points with the selected color
      var ds = gadget.dashboard.getDataSet(getSelectedDataset());
   	var colorIndexArray = ds.getColoredIndexArray();
   	var dsData = ds.toJSON();
   	
      var newDb = [];
      for (var i = 0; i < colorIndexArray.length; i++) {
      	if (getSelectionMarkerColor() == colorIndexArray[i][1]) {
      		newDb.push(dsData[i]);
      	}
      }
      
      var newDs = gadget.dashboard.createDataSet(dsName);
      newDs.init(newDb);
       
   }
	
	my.doPlot = function() {
		// Read the values in from the forms
		maxDensity = document.getElementById('maxDensityInput').value;
		numBinsX = document.getElementById('numBinsXInput').value;
		imgPath = document.getElementById('imgURLInput').value;
		imgPosX = document.getElementById('imgPosXInput').value;
		imgPosY = document.getElementById('imgPosYInput').value;
		imgWidth = document.getElementById('imgWidthInput').value;
		imgHeight = document.getElementById('imgHeightInput').value;
		
		// Init the dataset
		currentDatasetName = getSelectedDataset();
      var datasetName = currentDatasetName;
      var xAxisName = getSelectedXAxis();
      var yAxisName = getSelectedYAxis();
      
      //TODO: confirm dataset actually exists with this name
      if (datasetName ===  "" || xAxisName === "" || yAxisName === "") {
      	alert("Choose a dataset, x axis, and y axis");
      	return;
      }
      
      var dataInput = { 'dataSetName': datasetName,
                        'xAxis': getSelectedXAxis(),
                        'yAxis': getSelectedYAxis()
                      };
		
		// Read the data in and figure out the max and min of the dataset
		dataToPlot = parseData(dataInput);
		dataExtremes = getDataExtremes(dataToPlot);
		
		displayPlot(dataInput);
	}
	
	my.setSelectOptions = function(sel, array) {
   	setSelectOptions(sel, array);
   }

	return my;	
}

</script>
</head>
<body onload="init();">
<div id="content">
	<!-- The scatter plot -->
	<div id="divChart1" style="width: 600px; height: 400px; margin: 0 auto"></div>

	<!-- The plot controls -->
	Dataset: <select id="selDatasetName" onchange="pl.populateXYSelect(this.options[this.selectedIndex].value);"></select>
	X-Axis: <!--<input id="butXInvert" type="button" title="Invert X Axis" value=">" onclick="pl.invertX();"></input>--><select id="selXAxis"></select>
	Y-Axis: <!--<input id="butYInvert" type="button" title="Invert Y Axis" value="^" onclick="pl.invertY();"></input>--><select id="selYAxis"></select><br>
	<input id="btDoPlot" onclick="pl.doPlot();" type="button" value="Plot"/><br>
	
	maxDensity: <input type="text" id="maxDensityInput" value="2" /><br>
	numBinsX: <input type="text" id="numBinsXInput" value="35" /><br>
	imgURL: <input type="text" id="imgURLInput" value="http://www.stlukeseye.com/images/img-amsler-grid.gif" /><br>
	imgPosX: <input type="text" id="imgPosXInput" value="11.8" /><br>
	imgPosY: <input type="text" id="imgPosYInput" value="11.8" /><br>
	imgWidth: <input type="text" id="imgWidthInput" value="0.1" /><br>
	imgHeight: <input type="text" id="imgHeightInput" value="0.1" /><br>
   <form name="formSelectZoom">
   	<div id="divSelectZoom" style="padding: 5px">
      	Selection Color: <select id="selSelectionColor"></select>
         <input type="radio" id="radSelectZoom" name="radSelectZoom" value="select" checked="checked" /><label for="radSelect">Select</label>
         <input type="radio" id="radSelectZoom" name="radSelectZoom" value="zoom" /><label for="radZoom">Zoom</label>
   	</div>
	</form>
	
	<input id="btExportSelected" onclick="pl.exportSelected();" type="button" value="Export Selection"/>
	Name: <input type="text" id="exportSelectedInput" value="selected" />
</div>

</body>
</html>
